<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Solar System WebGL</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 200px;
            line-height: 1.4;
        }
        #fps {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #planetInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        .planet-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }
        .planet-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .planet-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid #fff;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <div style="font-weight: bold; margin-bottom: 10px;">üåå Complete Solar System</div>
        <div>üñ±Ô∏è Drag to rotate camera</div>
        <div>üñ±Ô∏è Scroll to zoom</div>
        <div>‚è±Ô∏è Real orbital mechanics</div>
        <div>üéØ 8 planets + moons</div>
    </div>
    <div id="fps">FPS: <span id="fpsValue">0</span></div>
    
    <div id="planetInfo">
        <div style="font-weight: bold; margin-bottom: 8px;">Planetary System</div>
        <div class="planet-list">
            <div class="planet-item">
                <div class="planet-color" style="background: #FFA500;"></div>
                <span>‚òÄÔ∏è Sun</span>
            </div>
            <div class="planet-item">
                <div class="planet-color" style="background: #8C7853;"></div>
                <span>‚òøÔ∏è Mercury</span>
            </div>
            <div class="planet-item">
                <div class="planet-color" style="background: #FFC649;"></div>
                <span>‚ôÄÔ∏è Venus</span>
            </div>
            <div class="planet-item">
                <div class="planet-color" style="background: #6B93D6;"></div>
                <span>üåç Earth + Moon</span>
            </div>
            <div class="planet-item">
                <div class="planet-color" style="background: #CD5C5C;"></div>
                <span>‚ôÇÔ∏è Mars</span>
            </div>
            <div class="planet-item">
                <div class="planet-color" style="background: #D8CA9D;"></div>
                <span>‚ôÉ Jupiter + Moons</span>
            </div>
            <div class="planet-item">
                <div class="planet-color" style="background: #FAD5A5;"></div>
                <span>‚ôÑ Saturn + Rings</span>
            </div>
            <div class="planet-item">
                <div class="planet-color" style="background: #4FD0E3;"></div>
                <span>‚ôÖ Uranus</span>
            </div>
        </div>
        <div style="margin-top: 5px;">
            <div class="planet-item">
                <div class="planet-color" style="background: #4B70DD;"></div>
                <span>‚ôÜ Neptune</span>
            </div>
        </div>
    </div>

    <script>
        // Vertex shader for celestial bodies
        const vertexShaderSource = `
            attribute vec3 a_position;
            attribute vec3 a_normal;
            attribute vec2 a_texCoord;
            
            uniform mat4 u_modelMatrix;
            uniform mat4 u_viewMatrix;
            uniform mat4 u_projectionMatrix;
            uniform mat3 u_normalMatrix;
            
            varying vec3 v_normal;
            varying vec3 v_position;
            varying vec2 v_texCoord;
            varying vec3 v_worldPosition;
            
            void main() {
                vec4 worldPosition = u_modelMatrix * vec4(a_position, 1.0);
                gl_Position = u_projectionMatrix * u_viewMatrix * worldPosition;
                
                v_normal = normalize(u_normalMatrix * a_normal);
                v_position = a_position;
                v_texCoord = a_texCoord;
                v_worldPosition = worldPosition.xyz;
            }
        `;

        // Fragment shader for the Sun with enhanced pulsing glow
        const sunFragmentShaderSource = `
            precision mediump float;
            
            uniform float u_time;
            uniform vec3 u_cameraPosition;
            
            varying vec3 v_normal;
            varying vec3 v_position;
            varying vec3 v_worldPosition;
            
            void main() {
                float pulse = 0.85 + 0.15 * sin(u_time * 2.5);
                float pulse2 = 0.9 + 0.1 * sin(u_time * 4.0);
                
                // Core sun color with multiple pulse frequencies
                vec3 sunColor = vec3(1.0, 0.8, 0.2) * pulse * pulse2;
                
                // Solar surface activity simulation
                float surface1 = sin(v_position.x * 6.0 + u_time) * sin(v_position.y * 6.0 + u_time * 0.7);
                float surface2 = cos(v_position.z * 8.0 + u_time * 1.3) * sin(v_position.x * 4.0);
                float surfaceActivity = (surface1 + surface2) * 0.15;
                
                sunColor += vec3(0.3, 0.1, 0.0) * surfaceActivity * pulse;
                
                // Enhanced rim glow effect
                vec3 viewDir = normalize(u_cameraPosition - v_worldPosition);
                float rim = 1.0 - max(0.0, dot(v_normal, viewDir));
                rim = pow(rim, 1.5);
                
                sunColor += vec3(1.0, 0.7, 0.3) * rim * pulse * 0.8;
                
                // Corona effect
                float corona = pow(rim, 0.5) * pulse * 0.3;
                sunColor += vec3(1.0, 0.9, 0.6) * corona;
                
                gl_FragColor = vec4(sunColor, 1.0);
            }
        `;

        // Fragment shader for planets with enhanced lighting
        const planetFragmentShaderSource = `
            precision mediump float;
            
            uniform vec3 u_planetColor;
            uniform vec3 u_lightPosition;
            uniform vec3 u_cameraPosition;
            uniform float u_time;
            uniform float u_planetType; // 0=rocky, 1=gas giant
            
            varying vec3 v_normal;
            varying vec3 v_position;
            varying vec2 v_texCoord;
            varying vec3 v_worldPosition;
            
            void main() {
                vec3 lightDir = normalize(u_lightPosition - v_worldPosition);
                vec3 viewDir = normalize(u_cameraPosition - v_worldPosition);
                vec3 reflectDir = reflect(-lightDir, v_normal);
                
                // Ambient lighting
                vec3 ambient = 0.15 * u_planetColor;
                
                // Diffuse lighting
                float diff = max(dot(v_normal, lightDir), 0.0);
                vec3 diffuse = diff * u_planetColor;
                
                // Specular lighting (varies by planet type)
                float shininess = u_planetType > 0.5 ? 16.0 : 32.0;
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
                vec3 specular = vec3(0.2 + u_planetType * 0.1) * spec;
                
                // Surface patterns based on planet type
                float pattern;
                if (u_planetType > 0.5) {
                    // Gas giant - bands and storms
                    float bands = sin(v_texCoord.y * 15.0 + u_time * 0.1) * 0.1;
                    float storms = sin(v_texCoord.x * 8.0 + u_time * 0.3) * sin(v_texCoord.y * 12.0) * 0.05;
                    pattern = bands + storms;
                } else {
                    // Rocky planet - surface features
                    pattern = sin(v_texCoord.x * 25.0) * sin(v_texCoord.y * 20.0) * 0.08;
                    pattern += cos(v_texCoord.x * 35.0 + v_texCoord.y * 30.0) * 0.05;
                }
                
                // Terminator darkening (day/night transition)
                float terminator = smoothstep(-0.1, 0.1, diff);
                
                vec3 color = (ambient + diffuse * terminator + specular) + pattern * u_planetColor;
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Fragment shader for Saturn's rings
        const ringFragmentShaderSource = `
            precision mediump float;
            
            uniform vec3 u_ringColor;
            uniform float u_time;
            uniform float u_innerRadius;
            uniform float u_outerRadius;
            
            varying vec3 v_position;
            varying vec2 v_texCoord;
            
            void main() {
                float distance = length(v_position.xz);
                
                // Ring boundaries
                if (distance < u_innerRadius || distance > u_outerRadius) {
                    discard;
                }
                
                // Ring density variations
                float ringPattern = sin(distance * 50.0) * 0.3 + 0.7;
                ringPattern *= sin(distance * 120.0 + u_time) * 0.2 + 0.8;
                
                // Transparency based on distance from center
                float alpha = smoothstep(u_innerRadius, u_innerRadius + 0.1, distance) * 
                             smoothstep(u_outerRadius, u_outerRadius - 0.1, distance);
                alpha *= ringPattern * 0.6;
                
                gl_FragColor = vec4(u_ringColor, alpha);
            }
        `;

        class Matrix4 {
            constructor() {
                this.elements = new Float32Array(16);
                this.identity();
            }
            
            identity() {
                const e = this.elements;
                e[0] = 1; e[4] = 0; e[8] = 0;  e[12] = 0;
                e[1] = 0; e[5] = 1; e[9] = 0;  e[13] = 0;
                e[2] = 0; e[6] = 0; e[10] = 1; e[14] = 0;
                e[3] = 0; e[7] = 0; e[11] = 0; e[15] = 1;
                return this;
            }
            
            perspective(fovy, aspect, near, far) {
                const e = this.elements;
                const f = 1.0 / Math.tan(fovy / 2);
                const rangeInv = 1 / (near - far);
                
                e[0] = f / aspect; e[4] = 0; e[8] = 0; e[12] = 0;
                e[1] = 0; e[5] = f; e[9] = 0; e[13] = 0;
                e[2] = 0; e[6] = 0; e[10] = (near + far) * rangeInv; e[14] = near * far * rangeInv * 2;
                e[3] = 0; e[7] = 0; e[11] = -1; e[15] = 0;
                return this;
            }
            
            lookAt(eye, center, up) {
                const e = this.elements;
                const fx = center[0] - eye[0];
                const fy = center[1] - eye[1];
                const fz = center[2] - eye[2];
                const rlf = 1 / Math.sqrt(fx*fx + fy*fy + fz*fz);
                const fx_norm = fx * rlf;
                const fy_norm = fy * rlf;
                const fz_norm = fz * rlf;
                
                const sx = fy_norm * up[2] - fz_norm * up[1];
                const sy = fz_norm * up[0] - fx_norm * up[2];
                const sz = fx_norm * up[1] - fy_norm * up[0];
                const rls = 1 / Math.sqrt(sx*sx + sy*sy + sz*sz);
                const sx_norm = sx * rls;
                const sy_norm = sy * rls;
                const sz_norm = sz * rls;
                
                const ux = sy_norm * fz_norm - sz_norm * fy_norm;
                const uy = sz_norm * fx_norm - sx_norm * fz_norm;
                const uz = sx_norm * fy_norm - sy_norm * fx_norm;
                
                e[0] = sx_norm; e[4] = ux; e[8] = -fx_norm; e[12] = 0;
                e[1] = sy_norm; e[5] = uy; e[9] = -fy_norm; e[13] = 0;
                e[2] = sz_norm; e[6] = uz; e[10] = -fz_norm; e[14] = 0;
                e[3] = 0; e[7] = 0; e[11] = 0; e[15] = 1;
                
                const te = new Matrix4();
                te.elements[12] = -(sx_norm * eye[0] + sy_norm * eye[1] + sz_norm * eye[2]);
                te.elements[13] = -(ux * eye[0] + uy * eye[1] + uz * eye[2]);
                te.elements[14] = -(-fx_norm * eye[0] + -fy_norm * eye[1] + -fz_norm * eye[2]);
                
                this.multiply(te);
                return this;
            }
            
            translate(x, y, z) {
                const e = this.elements;
                e[12] = e[0] * x + e[4] * y + e[8] * z + e[12];
                e[13] = e[1] * x + e[5] * y + e[9] * z + e[13];
                e[14] = e[2] * x + e[6] * y + e[10] * z + e[14];
                e[15] = e[3] * x + e[7] * y + e[11] * z + e[15];
                return this;
            }
            
            rotateY(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const e = this.elements;
                
                const m11 = e[0], m21 = e[1], m31 = e[2], m41 = e[3];
                const m13 = e[8], m23 = e[9], m33 = e[10], m43 = e[11];
                
                e[0] = c * m11 + s * m13;
                e[1] = c * m21 + s * m23;
                e[2] = c * m31 + s * m33;
                e[3] = c * m41 + s * m43;
                
                e[8] = c * m13 - s * m11;
                e[9] = c * m23 - s * m21;
                e[10] = c * m33 - s * m31;
                e[11] = c * m43 - s * m41;
                return this;
            }
            
            rotateX(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const e = this.elements;
                
                const m12 = e[4], m22 = e[5], m32 = e[6], m42 = e[7];
                const m13 = e[8], m23 = e[9], m33 = e[10], m43 = e[11];
                
                e[4] = c * m12 - s * m13;
                e[5] = c * m22 - s * m23;
                e[6] = c * m32 - s * m33;
                e[7] = c * m42 - s * m43;
                
                e[8] = s * m12 + c * m13;
                e[9] = s * m22 + c * m23;
                e[10] = s * m32 + c * m33;
                e[11] = s * m42 + c * m43;
                return this;
            }
            
            rotateZ(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const e = this.elements;
                
                const m11 = e[0], m21 = e[1], m31 = e[2], m41 = e[3];
                const m12 = e[4], m22 = e[5], m32 = e[6], m42 = e[7];
                
                e[0] = c * m11 + s * m12;
                e[1] = c * m21 + s * m22;
                e[2] = c * m31 + s * m32;
                e[3] = c * m41 + s * m42;
                
                e[4] = c * m12 - s * m11;
                e[5] = c * m22 - s * m21;
                e[6] = c * m32 - s * m31;
                e[7] = c * m42 - s * m41;
                return this;
            }
            
            scale(x, y, z) {
                const e = this.elements;
                e[0] *= x; e[4] *= y; e[8] *= z;
                e[1] *= x; e[5] *= y; e[9] *= z;
                e[2] *= x; e[6] *= y; e[10] *= z;
                e[3] *= x; e[7] *= y; e[11] *= z;
                return this;
            }
            
            multiply(m) {
                const ae = this.elements;
                const be = m.elements;
                const te = new Float32Array(16);
                
                const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
                const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
                const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
                const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
                
                const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
                const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
                const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
                const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
                
                te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                
                te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                
                te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                
                te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                
                this.elements = te;
                return this;
            }
            
            clone() {
                const m = new Matrix4();
                m.elements.set(this.elements);
                return m;
            }
            
            getNormalMatrix() {
                const e = this.elements;
                return new Float32Array([
                    e[0], e[1], e[2],
                    e[4], e[5], e[6],
                    e[8], e[9], e[10]
                ]);
            }
        }

        class SolarSystem {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = this.canvas.getContext('webgl');
                
                if (!this.gl) {
                    alert('WebGL not supported');
                    return;
                }
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.camera = {
                    distance: 25,
                    rotation: { x: 0, y: 0 },
                    position: [0, 0, 25]
                };
                
                this.mouse = {
                    isDown: false,
                    lastX: 0,
                    lastY: 0
                };
                
                this.time = 0;
                this.fpsCounter = 0;
                this.lastTime = performance.now();
                
                // Planetary data with realistic characteristics
                this.planets = [
                    { name: 'Mercury', distance: 3, speed: 4.15, size: 0.15, color: [0.55, 0.47, 0.33], type: 0 },
                    { name: 'Venus', distance: 4.5, speed: 1.62, size: 0.25, color: [1.0, 0.78, 0.29], type: 0 },
                    { name: 'Earth', distance: 6, speed: 1.0, size: 0.3, color: [0.42, 0.58, 0.84], type: 0, moon: true },
                    { name: 'Mars', distance: 8, speed: 0.53, size: 0.2, color: [0.8, 0.36, 0.36], type: 0 },
                    { name: 'Jupiter', distance: 12, speed: 0.084, size: 0.8, color: [0.85, 0.79, 0.62], type: 1, moons: 4 },
                    { name: 'Saturn', distance: 16, speed: 0.034, size: 0.7, color: [0.98, 0.84, 0.65], type: 1, rings: true, moons: 3 },
                    { name: 'Uranus', distance: 22, speed: 0.012, size: 0.4, color: [0.31, 0.82, 0.89], type: 1 },
                    { name: 'Neptune', distance: 28, speed: 0.006, size: 0.38, color: [0.29, 0.44, 0.87], type: 1 }
                ];
                
                this.initEventListeners();
                this.initGL();
                this.createGeometry();
                this.animate();
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }
            
            initEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => {
                    this.mouse.isDown = true;
                    this.mouse.lastX = e.clientX;
                    this.mouse.lastY = e.clientY;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (!this.mouse.isDown) return;
                    
                    const deltaX = e.clientX - this.mouse.lastX;
                    const deltaY = e.clientY - this.mouse.lastY;
                    
                    this.camera.rotation.y += deltaX * 0.01;
                    this.camera.rotation.x += deltaY * 0.01;
                    
                    this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotation.x));
                    
                    this.mouse.lastX = e.clientX;
                    this.mouse.lastY = e.clientY;
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.isDown = false;
                });
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.camera.distance += e.deltaY * 0.02;
                    this.camera.distance = Math.max(8, Math.min(80, this.camera.distance));
                });
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1) {
                        this.mouse.isDown = true;
                        this.mouse.lastX = e.touches[0].clientX;
                        this.mouse.lastY = e.touches[0].clientY;
                    }
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.mouse.isDown || e.touches.length !== 1) return;
                    
                    const deltaX = e.touches[0].clientX - this.mouse.lastX;
                    const deltaY = e.touches[0].clientY - this.mouse.lastY;
                    
                    this.camera.rotation.y += deltaX * 0.01;
                    this.camera.rotation.x += deltaY * 0.01;
                    
                    this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotation.x));
                    
                    this.mouse.lastX = e.touches[0].clientX;
                    this.mouse.lastY = e.touches[0].clientY;
                });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.mouse.isDown = false;
                });
            }
            
            initGL() {
                const gl = this.gl;
                
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.clearColor(0.0, 0.0, 0.05, 1.0);
                
                // Create shader programs
                this.sunProgram = this.createShaderProgram(vertexShaderSource, sunFragmentShaderSource);
                this.planetProgram = this.createShaderProgram(vertexShaderSource, planetFragmentShaderSource);
                this.ringProgram = this.createShaderProgram(vertexShaderSource, ringFragmentShaderSource);
            }
            
            createShaderProgram(vertexSource, fragmentSource) {
                const gl = this.gl;
                
                const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program linking error:', gl.getProgramInfoLog(program));
                    return null;
                }
                
                return program;
            }
            
            createShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            createGeometry() {
                this.sphere = this.createSphere(1, 32, 16);
                this.ring = this.createRing(1.5, 2.5, 64);
            }
            
            createSphere(radius, widthSegments, heightSegments) {
                const positions = [];
                const normals = [];
                const texCoords = [];
                const indices = [];
                
                for (let i = 0; i <= heightSegments; i++) {
                    const theta = i * Math.PI / heightSegments;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    
                    for (let j = 0; j <= widthSegments; j++) {
                        const phi = j * 2 * Math.PI / widthSegments;
                        const sinPhi = Math.sin(phi);
                        const cosPhi = Math.cos(phi);
                        
                        const x = cosPhi * sinTheta;
                        const y = cosTheta;
                        const z = sinPhi * sinTheta;
                        
                        positions.push(radius * x, radius * y, radius * z);
                        normals.push(x, y, z);
                        texCoords.push(j / widthSegments, i / heightSegments);
                    }
                }
                
                for (let i = 0; i < heightSegments; i++) {
                    for (let j = 0; j < widthSegments; j++) {
                        const first = i * (widthSegments + 1) + j;
                        const second = first + widthSegments + 1;
                        
                        indices.push(first, second, first + 1);
                        indices.push(second, second + 1, first + 1);
                    }
                }
                
                return this.createBuffers(positions, normals, texCoords, indices);
            }
            
            createRing(innerRadius, outerRadius, segments) {
                const positions = [];
                const normals = [];
                const texCoords = [];
                const indices = [];
                
                for (let i = 0; i <= segments; i++) {
                    const angle = i * 2 * Math.PI / segments;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    // Inner vertex
                    positions.push(innerRadius * cos, 0, innerRadius * sin);
                    normals.push(0, 1, 0);
                    texCoords.push(0, i / segments);
                    
                    // Outer vertex
                    positions.push(outerRadius * cos, 0, outerRadius * sin);
                    normals.push(0, 1, 0);
                    texCoords.push(1, i / segments);
                }
                
                for (let i = 0; i < segments; i++) {
                    const base = i * 2;
                    indices.push(base, base + 1, base + 2);
                    indices.push(base + 1, base + 3, base + 2);
                }
                
                return this.createBuffers(positions, normals, texCoords, indices);
            }
            
            createBuffers(positions, normals, texCoords, indices) {
                const gl = this.gl;
                
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                
                const normalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
                
                const texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
                
                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                
                return {
                    positionBuffer,
                    normalBuffer,
                    texCoordBuffer,
                    indexBuffer,
                    indexCount: indices.length
                };
            }
            
            updateCamera() {
                const x = this.camera.distance * Math.cos(this.camera.rotation.x) * Math.sin(this.camera.rotation.y);
                const y = this.camera.distance * Math.sin(this.camera.rotation.x);
                const z = this.camera.distance * Math.cos(this.camera.rotation.x) * Math.cos(this.camera.rotation.y);
                
                this.camera.position = [x, y, z];
            }
            
            setupUniforms(program, modelMatrix) {
                const gl = this.gl;
                
                const modelMatrixLocation = gl.getUniformLocation(program, 'u_modelMatrix');
                const viewMatrixLocation = gl.getUniformLocation(program, 'u_viewMatrix');
                const projectionMatrixLocation = gl.getUniformLocation(program, 'u_projectionMatrix');
                const normalMatrixLocation = gl.getUniformLocation(program, 'u_normalMatrix');
                
                const projectionMatrix = new Matrix4().perspective(Math.PI/4, this.canvas.width/this.canvas.height, 0.1, 200);
                const viewMatrix = new Matrix4().lookAt(this.camera.position, [0, 0, 0], [0, 1, 0]);
                
                gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix.elements);
                gl.uniformMatrix4fv(viewMatrixLocation, false, viewMatrix.elements);
                gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix.elements);
                gl.uniformMatrix3fv(normalMatrixLocation, false, modelMatrix.getNormalMatrix());
            }
            
            setupAttributes(geometry) {
                const gl = this.gl;
                const program = gl.getParameter(gl.CURRENT_PROGRAM);
                
                const positionAttribute = gl.getAttribLocation(program, 'a_position');
                const normalAttribute = gl.getAttribLocation(program, 'a_normal');
                const texCoordAttribute = gl.getAttribLocation(program, 'a_texCoord');
                
                gl.bindBuffer(gl.ARRAY_BUFFER, geometry.positionBuffer);
                gl.enableVertexAttribArray(positionAttribute);
                gl.vertexAttribPointer(positionAttribute, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, geometry.normalBuffer);
                gl.enableVertexAttribArray(normalAttribute);
                gl.vertexAttribPointer(normalAttribute, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, geometry.texCoordBuffer);
                gl.enableVertexAttribArray(texCoordAttribute);
                gl.vertexAttribPointer(texCoordAttribute, 2, gl.FLOAT, false, 0, 0);
            }
            
            drawSun() {
                const gl = this.gl;
                gl.useProgram(this.sunProgram);
                
                const sunMatrix = new Matrix4().scale(1.2, 1.2, 1.2);
                this.setupUniforms(this.sunProgram, sunMatrix);
                this.setupAttributes(this.sphere);
                
                const timeLocation = gl.getUniformLocation(this.sunProgram, 'u_time');
                const cameraPositionLocation = gl.getUniformLocation(this.sunProgram, 'u_cameraPosition');
                gl.uniform1f(timeLocation, this.time);
                gl.uniform3fv(cameraPositionLocation, this.camera.position);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.sphere.indexBuffer);
                gl.drawElements(gl.TRIANGLES, this.sphere.indexCount, gl.UNSIGNED_SHORT, 0);
            }
            
            drawPlanet(planet, angle) {
                const gl = this.gl;
                gl.useProgram(this.planetProgram);
                
                const planetMatrix = new Matrix4()
                    .translate(Math.cos(angle) * planet.distance, 0, Math.sin(angle) * planet.distance)
                    .rotateY(this.time * (planet.speed + 1))
                    .scale(planet.size, planet.size, planet.size);
                
                this.setupUniforms(this.planetProgram, planetMatrix);
                this.setupAttributes(this.sphere);
                
                const planetColorLocation = gl.getUniformLocation(this.planetProgram, 'u_planetColor');
                const lightPositionLocation = gl.getUniformLocation(this.planetProgram, 'u_lightPosition');
                const cameraPositionLocation = gl.getUniformLocation(this.planetProgram, 'u_cameraPosition');
                const timeLocation = gl.getUniformLocation(this.planetProgram, 'u_time');
                const planetTypeLocation = gl.getUniformLocation(this.planetProgram, 'u_planetType');
                
                gl.uniform3fv(planetColorLocation, planet.color);
                gl.uniform3fv(lightPositionLocation, [0, 0, 0]);
                gl.uniform3fv(cameraPositionLocation, this.camera.position);
                gl.uniform1f(timeLocation, this.time);
                gl.uniform1f(planetTypeLocation, planet.type);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.sphere.indexBuffer);
                gl.drawElements(gl.TRIANGLES, this.sphere.indexCount, gl.UNSIGNED_SHORT, 0);
                
                return [Math.cos(angle) * planet.distance, 0, Math.sin(angle) * planet.distance];
            }
            
            drawMoon(planetPosition, planetAngle, moonIndex = 0) {
                const gl = this.gl;
                
                const moonOrbitRadius = 0.8 + moonIndex * 0.3;
                const moonOrbitSpeed = 4 + moonIndex * 1.5;
                const moonAngle = this.time * moonOrbitSpeed + moonIndex * Math.PI / 2;
                
                const moonMatrix = new Matrix4()
                    .translate(planetPosition[0], planetPosition[1], planetPosition[2])
                    .translate(Math.cos(moonAngle) * moonOrbitRadius, 0, Math.sin(moonAngle) * moonOrbitRadius)
                    .rotateY(this.time * (2 + moonIndex))
                    .scale(0.08 + moonIndex * 0.02, 0.08 + moonIndex * 0.02, 0.08 + moonIndex * 0.02);
                
                this.setupUniforms(this.planetProgram, moonMatrix);
                
                const moonColor = moonIndex === 0 ? [0.8, 0.8, 0.7] : [0.7, 0.7, 0.65];
                
                const planetColorLocation = gl.getUniformLocation(this.planetProgram, 'u_planetColor');
                const lightPositionLocation = gl.getUniformLocation(this.planetProgram, 'u_lightPosition');
                const cameraPositionLocation = gl.getUniformLocation(this.planetProgram, 'u_cameraPosition');
                const timeLocation = gl.getUniformLocation(this.planetProgram, 'u_time');
                const planetTypeLocation = gl.getUniformLocation(this.planetProgram, 'u_planetType');
                
                gl.uniform3fv(planetColorLocation, moonColor);
                gl.uniform3fv(lightPositionLocation, [0, 0, 0]);
                gl.uniform3fv(cameraPositionLocation, this.camera.position);
                gl.uniform1f(timeLocation, this.time);
                gl.uniform1f(planetTypeLocation, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.sphere.indexBuffer);
                gl.drawElements(gl.TRIANGLES, this.sphere.indexCount, gl.UNSIGNED_SHORT, 0);
            }
            
            drawRings(planetPosition) {
                const gl = this.gl;
                gl.useProgram(this.ringProgram);
                
                const ringMatrix = new Matrix4()
                    .translate(planetPosition[0], planetPosition[1], planetPosition[2])
                    .rotateX(Math.PI / 6)
                    .rotateY(this.time * 0.1);
                
                this.setupUniforms(this.ringProgram, ringMatrix);
                this.setupAttributes(this.ring);
                
                const ringColorLocation = gl.getUniformLocation(this.ringProgram, 'u_ringColor');
                const timeLocation = gl.getUniformLocation(this.ringProgram, 'u_time');
                const innerRadiusLocation = gl.getUniformLocation(this.ringProgram, 'u_innerRadius');
                const outerRadiusLocation = gl.getUniformLocation(this.ringProgram, 'u_outerRadius');
                
                gl.uniform3fv(ringColorLocation, [0.9, 0.8, 0.6]);
                gl.uniform1f(timeLocation, this.time);
                gl.uniform1f(innerRadiusLocation, 1.5);
                gl.uniform1f(outerRadiusLocation, 2.5);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ring.indexBuffer);
                gl.drawElements(gl.TRIANGLES, this.ring.indexCount, gl.UNSIGNED_SHORT, 0);
            }
            
            render() {
                const gl = this.gl;
                
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                this.updateCamera();
                
                // Draw Sun
                this.drawSun();
                
                // Draw all planets
                this.planets.forEach((planet, index) => {
                    const angle = this.time * planet.speed;
                    const planetPosition = this.drawPlanet(planet, angle);
                    
                    // Draw moons
                    if (planet.moon) {
                        this.drawMoon(planetPosition, angle);
                    } else if (planet.moons) {
                        for (let i = 0; i < planet.moons; i++) {
                            this.drawMoon(planetPosition, angle, i);
                        }
                    }
                    
                    // Draw rings for Saturn
                    if (planet.rings) {
                        this.drawRings(planetPosition);
                    }
                });
            }
            
            animate() {
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.time += deltaTime * 0.0008; // Slowed down for better viewing
                
                // FPS counter
                this.fpsCounter++;
                if (this.fpsCounter % 60 === 0) {
                    const fps = Math.round(1000 / deltaTime);
                    document.getElementById('fpsValue').textContent = fps;
                }
                
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Start the application
        window.addEventListener('load', () => {
            new SolarSystem();
        });
    </script>
</body>
</html>
